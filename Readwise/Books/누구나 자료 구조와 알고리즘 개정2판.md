# 누구나 자료 구조와 알고리즘 개정2판

![rw-book-cover](https://readwise-assets.s3.amazonaws.com/static/images/default-book-icon-3.40504e56b01b.png)

## Metadata
- Author: [[제이 웬그로우]]
- Full Title: 누구나 자료 구조와 알고리즘 개정2판
- Category: #books

## Highlights
- 컴퓨터는 모든 메모리 주소에 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.
- 자료 구조의 성능 측정은 연산에 필요한 단계 수를 구하는 게 핵심
- 사용할 알고리즘을 적절하게 선택하는 문제
- 알고리즘이란 단순히 어떤 과제를 완수하는 명령어 집합
    - Tags: [[green]] 
- 어떤 코드를 작성하든 컴퓨터가 따르고 실행할 알고리즘을 만드는 것
- 정렬된 배열(ordered array)은 1장에서 설명한 “전형적인” 배열과 거의 같다. 유일한 차이는 정렬된 배열이라는 이름에서 추측할 수 있듯이 값이 항상 순서대로 있어야 한다는 점
    - Tags: [[green]] 
- 75가 들어갈 올바른 위치를 찾아야 하고, 이후 다른 값들을 옮겨 빈 공간을 만들어야 한다.
- 때때로 같은 과제를 둘 이상의 알고리즘으로 완수할 수 있다.
- 삽입에 필요한 단계 수는 새 값이 정렬된 배열 어디에 놓이게 되든 비슷하다.
- 삽입에 있어 정렬된 배열이 전형적인 배열보다 덜 효율적이지만, 정렬된 배열의 강력함은 검색 연산에서 드러난다.
- 컴퓨터가 한 번에 한 셀씩 확인하는 방법을 선형 검색
    - Tags: [[green]] 
- N개의 셀로 이뤄진 배열은 선형 검색에 최대 N개의 단계가 필요
- 배열의 끝에 도달하기 전에 검색을 멈추는 경우는 원하는 값을 찾았을 때뿐이다.
  하지만 정렬된 배열에서는 값이 배열에 들어있지 않을 때 검색을 더 빨리 멈출 수 있다.
- 선형 검색은 특정 상황에서 전형적인 배열보다 정렬된 배열에서 단계 수가 더 적게 걸린다. 하지만 찾으려는 값이 배열의 마지막 값이거나 마지막 값보다 크면 마찬가지로 모든 셀을 검색해야 검색이 끝난다.
- 선형 검색은 값을 검색하는 알고리즘 중 하나일 뿐이다. 사용할 수 있는 유일한 알고리즘이 아니다.
  정렬된 배열이 전형적인 배열보다 크게 두드러진 장점은 다른 검색 알고리즘을 쓸 수 있다는 점이다. 이러한 알고리즘을 이진 검색(binary search)이라 부르며, 이진 검색은 선형 검색보다 훨씬 빠르다.
- 이진 검색은 정렬된 배열에만 쓸 수 있다.
- binary_search도 array와 search_value를 인수로 받는다.
    - Tags: [[blue]] 
- search_value가 있을 수 있는 인덱스 범위를 정한다.
    - Tags: [[blue]] 
- search_value가 전체 배열 어디에든 있을 수 있으므로 lower_bound를 첫 번째 인덱스로, upper_bound를 마지막 인덱스로 정한다.
    - Tags: [[blue]] 
- 경쟁 알고리즘 간 성능을 분석하는 방법은 각각에 필요한 단계 수를 세는 것
- 선형 검색의 효율성을 정량화하는 보다 효과적인 방법은 배열에 N개의 원소가 있을 때 선형 검색에 N단계가 필요하다고 표현하는 것
- 빅 오 표기법이라 부르며, 빅 오 표기법을 사용해 주어진 알고리즘의 효율성을 쉽게 분류하고 이해시킬 수 있다.
- 수학에서 유래
    - Tags: [[purple]] 
- 빅 오는 특정 방식으로 알고리즘에 필요한 단계 수를 고려함으로써 일관성을 유지
- “데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요할까?”
- 이 책 전반에서 사용할 빅 오 표기법의 정의
- N이 얼마든 항상 상수 단계만 필요하다. 그래서 O(1) 알고리즘을 상수 시간(constant time)을 갖는 알고리즘이라고도 표현
- 빅 오를 함수 증가율의 상한값으로 설명하거나 함수 g(x)가 함수 f(x)보다 빠를 수 없을 때 g는 O(f)에 속한다고 말하기도 한다.
    - Tags: [[purple]] 
- 빅 오 표기법은 머릿속에 새겼던 핵심 질문, 즉 데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요한가에 대한 답이다.
- 데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는지
- 빅 오는 단순히 알고리즘에 필요한 단계 수만 알려주지 않는다. 데이터가 늘어날 때 단계 수가 어떻게 증가하는지 설명
- 변화가 생기는 일정량의 데이터가 항상 있을 것이고 O(N)은 그 순간부터 무한대까지 더 많은 단계가 걸리므로 O(1) 알고리즘에 실제로 몇 단계가 걸리든 O(N)이 전반적으로 O(1)보다 덜 효율적
- 데이터가 증가할수록 O(N)이 O(1)보다 덜 효율적인 어떤 지점에 반드시 다다르게 되며, 이 지점부터 데이터 양이 무한대로 갈 때까지 바뀌지 않는다.
- 별도로 명시하지 않는 한 빅 오 표기법은 일반적으로 최악의 시나리오를 의미
- 최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있다.
- 빅 오는 이진 검색의 시간 복잡도를 다음과 같이 설명한다.
  O(logN)
- 이러한 유형의 알고리즘을 로그 시간(log time)의 시간 복잡도
- 간단히 말해 O(logN)은 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘을 설명하는 빅 오의 방법
- O(1)
  O(logN)
  O(N)
- 로가리즘
- 로그는 로가리즘(logarithm)의 줄임말
    - Tags: [[purple]] 
- 로가리즘은 지수(exponent)와 역(inverse)의 관계
    - Tags: [[purple]] 
- 컴퓨터 과학에서 O(logN)은 사실 O(log2N)을 줄여 부르는 말
    - Tags: [[purple]] 
- 데이터 원소가 N개 일 때 알고리즘에 몇 단계가 필요할까?
    - Tags: [[purple]] 
- O(logN)은 데이터 원소가 N개 있을 때 알고리즘에 log2N단계가 걸린다는 의미
- O(logN)은 원소가 하나가 될 때까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻
- for 루프에 원소 수만큼 단계가 걸리므로 이 알고리즘의 효율성은 O(N)이라 할 수 있다.
- 함수로 전달된 수에 비례해 단계 수가 증가하므로 전형적인 O(N) 예제
- 주요 데이터가 배열이 아닌 수이므로 핵심 질문에서 대상으로 하는 N의 종류가 다르다.
- 빅 오를 사용하면 내가 만든 알고리즘과 세상에 존재하는 범용 알고리즘을 비교할 기회가 생기며 “이 알고리즘이 일반적으로 쓰이는 알고리즘만큼 빠른가 혹은 느린가?”라고 자문해 볼 수 있다.
- 정렬 알고리즘은 컴퓨터 과학 분야에서 폭넓게 연구된 주제
- 정렬되지 않은 배열이 주어졌을 때, 어떻게 오름차순으로 정렬할 수 있을까?
- 버블 정렬(bubble sort)
- unsorted_until_index 변수부터 생성한다. 이 변수는 아직 정렬되지 않은 배열의 가장 오른쪽 인덱스를 기록한다.
- 배열의 정렬 여부를 기록하는 sorted 변수도 생성한다. 물론, 코드가 처음 실행될 때는 정렬되지 않은 상태이므로 False를 할당한다.
- 배열이 정렬될 때까지 계속 실행될 while 루프를 시작
- sorted에 True를 할당
- 각 패스스루 안에서는 교환이 일어나기 전까지 배열이 정렬되어 있다고 가정하고 값을 교환하면 변수를 다시 False로 바꾸는 방식
- 어떤 교환도 하지 않고 전체 패스스루를 통과할 때 sorted가 True로 남아서 배열이 완전히 정렬된 상태임을 알 수 있다.
- for 루프 내에서는 모든 인접 값 쌍을 비교하고 순서가 뒤바뀌어 있으면 교환한다. 또한, 교환하게 되면 sorted를 False로 바꾼다.
- 오른쪽으로 올려준 값(버블)이 이제 올바른 위치에 있음을 알 수 있다. 바꿔 말하면 기존에 가리키고 있던 인덱스가 이제 정렬된 상태이니 unsorted_until_index 값을 1 감소
- sorted가 True가 되면, 즉 배열이 완전히 정렬되면 while 루프가 종료
- 비교
- 교환
- 모든 배열 크기에 적용되도록 표현하면 원소 N개가 있을 때,
  (N - 1) + (N - 2) + (N - 3) … + 1번의 비교를 수행
- 정렬된 최악의 시나리오라면 비교할 때마다 교환
- 원소 수가 증가할수록 단계 수가 기하급수적으로 늘어난다.
- N이 증가할 때마다 단계 수가 얼마씩 늘어나는지 살펴보면 대략 N2만큼 늘어남을 알게 된다.
- 값이 N개이므로 버블 정렬에는 N2단계가 필요하고, 따라서 빅 오로 나타내면 버블 정렬의 효율성은 O(N2)이다.
- 참고로 O(N2)을 이차 시간(quadratic time)이라고도 부른다.
- 읽기
- 중첩 루프를 사용하는 것
- 빅 오를 위 코드에 적용하려면 이렇게 물어야 한다. hasDuplicateValue 함수에 값 N개를 포함하는 배열이 주어졌을 때, 최악의 시나리오에서 알고리즘에 얼마나 많은 단계가 필요한가?
- 최악의 시나리오는 배열이 중복 값을 포함하지 않는 경우
- 결론적으로 배열에 값 N개가 있을 때 함수는 N2번의 비교를 수행
- 평점 배열에 중복 숫자가 들어 있는지 확인하는 함수를 작성
- 루프 내에 다른 루프를 중첩하는 알고리즘이라면 대부분(항상은 아니다) O(N2)이다. 따라서 중첩 루프가 보이면 O(N2) 알람이 머릿속에 울리기 시작해야 한다.
    - Tags: [[pink]] 
- 빅 오 관점에서 이 새로운 알고리즘의 효율성을 알아내려면 한 번 더 최악의 시나리오일 때 알고리즘에 필요한 단계 수를 알아내야 한다.
- 최악의 시나리오는 배열에 중복 값이 없을 때 발생한다. 이때 함수는 전체 루프를 모두 수행
- 코드는 적절한 인덱스에 1을 저장하기 앞서 이 인덱스의 값이 이미 1인지 확인한다. 1이면 이미 나왔던 숫자라는 뜻이며 따라서 중복 값을 찾은 것
- O(N)은 O(N2)보다 훨씬 빠르므로 두 번째 접근법을 사용함으로써 hasDuplicateValue를 크게 최적화했다. 엄청난 속도 향상
- 첫 번째 방식보다 메모리를 더 소비
    - Tags: [[blue]] 
- 빅 오 표기법을 명확히 이해하면 느린 코드를 식별해 내고 두 경쟁 알고리즘 중 더 빠른 알고리즘을 분명하게 골라낼 수 있다.
    - Tags: [[pink]] 
- 빅 오는 알고리즘을 서로 비교하고 주어진 상황에 알맞은 알고리즘을 결정하게 해주는 훌륭한 도구다. 하지만 빅 오가 유일한 도구는 아니다.
    - Tags: [[pink]] 
- 빅 오 표기법에서는 한 알고리즘이 다른 알고리즘보다 훨씬 빠른 경우에도 두 경쟁 알고리즘을 정확히 똑같은 방식으로 표현
    - Tags: [[pink]] 
- 선택 정렬
- 배열의 각 셀을 왼쪽부터 오른쪽 방향으로 확인하면서 어떤 값이 최솟값인지 결정한다. 한 셀씩 이동하면서 현재까지 가장 작은 값을 기록한다(실제로는 그 인덱스를 변수에 저장한다).
- 최솟값이 어느 인덱스에 들어 있는지 알았으므로 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.
- 배열 끝에서 시작하는 패스스루에 도달할 때까지 패스스루를 반복한다. 마지막 패스스루에서는 배열이 완벽히 정렬되어 있을 것이다.
