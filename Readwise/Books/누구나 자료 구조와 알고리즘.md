# 누구나 자료 구조와 알고리즘

![rw-book-cover](https://readwise-assets.s3.amazonaws.com/static/images/default-book-icon-6.71d9a01814f7.png)

## Metadata
- Author: [[제이 웬그로우]]
- Full Title: 누구나 자료 구조와 알고리즘
- Category: #books

## Highlights
- 컴퓨터 프로그램은 데이터를 입력받아 조작하고 반환하는 게 전부다.
- 데이터는 일반적으로 모든 유형의 정보를 망라하는 용어이며 가장 기초적인 수와 문자열로 이뤄진다.
- 매우 복잡한 데이터라도 대개는 수와 문자열 묶음
- 데이터를 조직하는 방법이 아니라 데이터 조직이 코드의 실행 속도에 미치는 영향이 크다는 것을 가르치고자 한다.
- 데이터 조직이 코드의 실행 속도에 미치는 영향이 크다는 것
- 배열
- 기초적인 자료 구조 중 하나
- 데이터 원소들의 리스트
- 배열의 인덱스
- 특정 데이터가 배열의 어디에 있는지 알려주는 숫자
- 자료 구조의 성능을 알려면 코드가 자료 구조와 일반적으로 어떻게 상호 작용하는지 분석
- 읽기
- 검색
- 삽입
- 삭제
- 자료 구조 내 특정 위치를 찾아보는 것
- 특정 인덱스의 값을 찾아보는 것
- 연산이 얼마나 “빠른가”를 측정할 때는 순수하게 시간 관점에서 연산이 얼마나 빠른가가 아니라 얼마나 많은 단계가 필요한지를 논해야 한다.
- 연산의 속도를 측정할 때 얼마나 많은 단계(step)가 필요한가
- 자료 구조 내에서 특정 값을 찾는 것
- 자료 구조에 새로운 값을 추가하는 것
- 자료 구조에서 값을 제거하는 것
- 배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾아보는 것
- 컴퓨터 과학자는 서로 간에 시간 복잡도를 쉽게 소통할 목적으로 자료 구조와 알고리즘의 효율성을 간결하고 일관된 언어로 설명하기 위해 수학적 개념을 차용
- 가령 빅 오를 함수 증가율의 상한값으로 설명하거나 함수 g(x)가 함수 f(x)보다 빠를 수 없을 때 g는 O(f)에 속한다고 말하기도 한다
- O(N)을 선형 시간(linear time)이라고도 부른다
- O(1)을 상수 시간(constant time)이라고도 부른다.
- 엄밀히 말하면 알고리즘에 한 단계보다 많은 세 단계가 걸리지만 빅 오 표기법은 이를 사소하게 여긴다. O(1)은 데이터가 아무리 커지더라도 단계 수가 변하지 않는 모든 알고리즘을 표현하는 방법이다.
- 변화가 생기는 일정량의 데이터가 항상 있을 것이고 O(N)은 그 순간부터 무한대까지 더 많은 단계가 걸리므로 O(N)은 전반적으로 O(1)보다 덜 효율적이라 할 수 있다.
  항상 백만 단계가 걸리는 O(1) 알고리즘이라도 마찬가지다.
- 빅 오가 주어진 알고리즘의 최선과 최악의 시나리오를 효과적으로 설명하긴 하지만, 별도로 명시하지 않는 한 빅 오 표기법은 일반적으로 최악의 시나리오를 의미한다.
- 이는 “비관적인” 접근이 유용한 도구일 수 있기 때문이다.
    - Note: 최악을 대비
- 이진 검색은 O(1)과 O(N) 사이 어디쯤엔가 있다.
  빅 오는 이진 검색의 시간 복잡도를 다음과 같이 설명한다.
  O(log N)
- O(log N)은 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘을 설명하는 빅 오의 방법이다.
- Highlighted Image: 064
- 로그는 로가리즘(logarithm)의 줄임말이다.
- 로가리즘은 지수와 역(inverse)의 관계다.
- log28을 다른 방식으로 설명하면 이렇다. 1이 될 때까지 8을 2로 계속해서 나눌 때 등식에 얼마나 많은 2가 등장할까?
  8 / 2 / 2 / 2 = 1
  다시 말해 1이 나올 때까지 8을 2로 몇 번 나눠야 할까? 예제에서는 3번이다.
- O(log N)은 원소가 하나가 될 때까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻이다.
- O(N) 알고리즘에는 데이터 원소 수만큼의 단계가 필요한 반면, O(log N) 알고리즘에는 데이터 원소가 두 배로 늘어날 때마다 딱 한 단계만 더 필요하다.
- 빅 오를 사용하면 내가 만든 알고리즘과 세상에 존재하는 범용 알고리즘을 비교할 기회가 생기며 “이 알고리즘이 일반적으로 쓰이는 알고리즘만큼 빠른가 혹은 느린가?”라고 자문해 볼 수 있다.
- 정렬 알고리즘은 컴퓨터 과학 분야에서 폭넓게 연구된 주제이며, 지난 수년간 수십 개의 정렬 알고리즘이 개발돼 왔다. 이러한 알고리즘 모두 다음의 문제를 해결한다.
  정렬되지 않은 배열이 주어졌을 때, 어떻게 오름차순으로 정렬할 수 있을까?
- 단순 정렬(simple sort)
- N이 증가할 때마다 단계 수가 얼마씩 늘어나는지 정확히 살펴보면 대략 N2만큼 늘어남을 알게 된다.
- 빅 오 표기법에서는 버블 정렬의 효율성을 O(N2)이라 부른다.
- 보다 형식적으로 표현하면, O(N2) 알고리즘은 데이터 원소가 N개일 때 대략 N2단계가 걸린다.
- O(N2)을 이차 시간(quadratic time)이라고도 부른다
- 빅 오를 위 코드에 적용하려면 이렇게 물어야 한다. hasDuplicateValue 함수에 원소 N개를 포함하는 포함하는 배열이 주어졌을 때, 최악의 시나리오에서 알고리즘에 얼마나 많은 단계가 걸리는가?
- 이차 문제
- 최악의 시나리오는 배열이 중복 값을 포함하지 않는 경우다.
- 결론적으로 배열에 원소 N개가 있을 때 함수는 N2번의 비교를 수행할 것이다.
- N2단계이므로 O(N2)의 알고리즘이다
- 단계 수를 기록하는 코드를 함수에 추가해서 실제로 증명할 수 있다.
    - Note: Var steps = 0
      Steps ++
- 알고리즘이 O(N2)이라는 사실은 진지하게 받아들여야 한다.
- 비교 외에 existingNumbers 배열에 삽입도 해야 하지만 이 분석에서는 삽입을 중요하지 않게 본다. 5장에서 더 설명하겠다.
    - Tags: [[green]] 
- 효율성이 같아 보이는 두 알고리즘을 구별해 내서 더 빠른 알고리즘을 고르는 법을 배우겠다.
- 선택 정렬(selection sort
- 교환은 한 패스스루 당 최대 한 번 일어난다.
- 선택 정렬은 분명 버블 정렬보다 단계 수가 반 정도 적다. 즉, 선택 정렬이 두 배 더 빠르다.
- 빅 오 표기법은 상수를 무시한다.
- 빅 오로는 정확히 같은 방법으로 표현되는 두 알고리즘이 있을 때, 한쪽이 다른 한쪽보다 100배나 빠를 수 있다는 점 때문에 이 규칙은 빅 오 표기법을 완전히 쓸모없게 만들어 버리는 것처럼 보인다.
- 빅 오가 상수를 무시하는 이유다. 빅 오는 특정 시점부터 어떤 유형이 다른 유형보다 속도가 빨라지고 이후로도 계속해서 더 빠른 경우 두 유형을 다르게 분류하고자 한다. 하지만 정확한 시점은 빅 오에서 중요하지 않다.
- 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로 빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구다.
- 빅 오에서 다른 분류에 속하는 알고리즘을 대조할 때는 빅 오가 완벽한 도구지만 같은 분류에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야 한다.
- 어느 정도 크기의 데이터에 대해서는 O(N)이 항상 O(N2)보다 빠르다.
- 따라서 빅 오에서 다른 분류에 속하는 알고리즘을 대조할 때는 빅 오가 완벽한 도구지만 같은 분류에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야 한다.
- 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로 빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구다.
- 지금까지는 알고리즘이 최악의 시나리오에서 얼마나 느린가에 초점을 맞췄다. 정의에 따르면 최악의 시나리오는 항상 일어나지 않는다. 대체로 일어나는 시나리오는 평균 시나리오다.
- 삽입 정렬(insersion sort)을 배우면서 최악의 경우(worst case)가 아닌 다른 시나리오를 분석하는 것에 어떤 장점이 있는지 알아보겠다.
- 인덱스 1부터 시작해 전체 배열을 순회하는 루프를 시작시킨다.
- 삽입 정렬에 포함된 단계는 삭제, 비교, 시프트, 삽입, 네 종류다.
- 총 비교 횟수를 다음과 같이 표현할 수 있다.
  1 + 2 + 3 + … + N–1번의 비교
- 빅 오 표기법은 가장 높은 차수의 N만 고려한다.
- 결론적으로 최악의 시나리오에서 삽입 정렬은 버블 정렬이나 선택 정렬과 시간 복잡도가 같다. 셋 모두 O(N2)이다.
- 버블 정렬은 N2단계인데 반해
- 선택 정렬은 N2 / 2단계로
- 삽입 정렬 역시 N2단계가 걸리므로(실제로는 N2 + 2N–2 단계)
- 최악의 시나리오에서는 선택 정렬이 삽입 정렬보다 빠른 게 사실이다. 하지만 평균 시나리오도 중요하게 고려해야 한다.
- 실제로는 대부분 평균 시나리오가 일어난다.
- 삽입 정렬이 시나리오에 따라 성능이 크게 좌우됨을 알았다.
- 최악의 시나리오에서 삽입 정렬은 N2단계가 걸린다. 평균 시나리오에서는 N2 / 2단계가 걸린다. 또한, 최선의 시나리오에서는 약 N단계가 걸린다.
- 임의로 정렬된 배열 같은 평균적인 경우라면 두 정렬은 유사하게 수행된다.
- 거의 정렬된 데이터를 다룰 거라고 가정할 수 있는 이유가 있다면 삽입 정렬이 더 낫다.
- 대부분 역순으로 정렬된 데이터를 다룰 거라고 가정할 수 있는 이유가 있다면 선택 정렬이 더 빠르다.
- 두 배열의 교집합을 구하는 자바스크립트 애플리케이션을 작성
    - Tags: [[green]] 
- 하이라이트된 이미지
    - Tags: [[green]] 
- 최악의 경우를 대비하는 것도 좋지만 대부분은 평균적인 경우가 일어난다는 점을 명심하자.
- 경쟁 알고리즘 중 주어진 상황(use case)에 맞는 알고리즘을 선택할 수 있는 능력이 생겼듯이 두 경쟁하는 자료 구조 중 더 나은 성능을 낼 수 있는 자료 구조를 선택하는 능력도 필요하다.
- 대부분의 프로그래밍 언어는 해시 테이블(hash table)이라는 자료 구조를 포함하며, 해시 테이블에는 빠른 읽기라는 놀랍고 엄청난 능력이 있다.
- 해시 테이블의 값 룩업은 딱 한 단계만 걸리므로 평균적으로 효율성이 O(1)이다.
- 해시 함수가 유효하려면 딱 한 가지 기준을 충족해야 한다. 해시 함수는 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다. 주어진 문자에 대해 반환하는 결과가 일관되지 않으면 그 해시 함수는 유효하지 않다.
- 곱셈 해시 함수를 쓰면 DAB 역시 BAD처럼 8로 변환된다는 것에 유의한다. 나중에 다루겠지만 이로 인해 실제로 문제가 발생한다.
- 문자를 가져와 숫자로 변환하는 이러한 과정을 해싱이라 부른다. 또한, 글자를 특정 숫자로 변환하는 데 사용한
- 코드를 해시 함수라 부른다.
- 배열과 유사하게 해시 테이블은 내부적으로 데이터를 한 줄로 이뤄진 셀 묶음에 저장한다.
- 먼저 컴퓨터는 키에 해시 함수를 적용한다.
- 컴퓨터는 룩업하고 있는 키를 해싱해서 해당하는 값을 얻고 그 값에 해당하는 셀로 바로 간다.
- 해시 테이블을 쓰면 실제 메뉴 항목을 키로 사용해서 해시 테이블 룩업을 O(1) 만에 할 수 있다.
- 충돌을 해결하는 고전적인 방법 하나가 분리 연결법이다.
- 셀에 하나의 값을 넣는 대신 배열로의 참조를 넣는 방법이다.
    - Note: 기존 들어있던 값 ‘evil’ 의 키가 ‘bad’라는 것은 별도로 저장해 두었다가 충돌이 나면 그때 배열로 만들기 위해 활용?
- 각 하위 배열의 인덱스 0을 찾아보며 룩업하고 있는 단어인 ("dab")을 찾을 때까지 배열을 차례대로 검색한다. 일치하는 하위 배열의 인덱스 1에 있는 값을 반환한다.
- 컴퓨터가 확인 중인 셀이 배열을 참조할 경우 다수의 값이 들어 있는 배열을 선형 검색해야 하므로 검색에 단계가 더 걸린다.
- 최악의 경우 해시 테이블 룩업 성능은 사실상 O(N)이다.
- 해시 테이블은 다음 세 요인에 따라 효율성이 정해진다.
  • 해시 테이블에 얼마나 많은 데이터를 저장하는가
  • 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가
  • 어떤 해시 함수를 사용하는가
- 좋은 해시 함수란 사용 가능한 모든 셀에 데이터를 분산시키는 함수다.
- 해시 테이블은 반드시 충돌 조정을 수행해야 한다. 좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피한다.
- 충돌 조정을 위해 컴퓨터 과학자는 다음과 같은 경험에 기반한 규칙을 세웠다. 해시 테이블에 저장된 데이터가 7개면 셀은 10개여야 한다.
- 데이터와 셀 간 이러한 비율을 부하율이라 부른다. 이 용어를 적용하면 이상적인 부하율은 0.7(원소 7개 / 셀 10개)이라 말할 수 있다.
- 해시 테이블 내부는 대부분 사용자가 쓰고 있는 컴퓨터 언어가 관리한다.
- 제약을 갖는 배열일 뿐이다. 하지만 바로 이러한 제약 덕분에 두 자료 구조가 매우 간결해진다.
- 스택과 큐는 임시 데이터를 처리할 수 있는 간결한 도구다.
- 임시 데이터란 처리 후에는 전혀 의미 없는 정보이므로 계속 유지하지 않아도 된다.
- • 데이터는 스택의 끝에만 삽입할 수 있다.
  • 데이터는 스택의 끝에서만 읽을 수 있다.
  • 데이터는 스택의 끝에서만 삭제할 수 있다.
- 스택에 새 값을 삽입하는 것을 스택에 푸시한다고도 말한다.
- 스택의 위에서 원소를 제거하는 것을 스택으로부터 팝한다고 한다.
- 오래 사용할 데이터를 저장할 때는 일반적으로 스택을 사용하지 않지만 임시 데이터를 다뤄야 하는 다양한 알고리즘에서는 스택이 유용한 도구다.
- 스택은 입력받은 순서와 반대로 데이터를 처리해야 할 때(LIFO) 항상 이상적이다.
- 워드 프로세서의 “되돌리기” 함수나 네트워크 애플리케이션에 쓰이는 함수 호출 등에서 스택이 유용
    - Tags: [[green]] 
- 큐 역시 큐에 첫 번째로 추가된 항목이 가장 먼저 제거
- • 데이터는 큐의 끝에만 삽입할 수 있다. (스택과 동일한 동작이다.)
  • 데이터는 큐의 앞에서만 읽을 수 있다. (스택과 정반대 동작이다.)
  • 데이터는 큐의 앞에서만 삭제할 수 있다. (마찬가지로 스택과 정반대 동작이다.)
- 출력 잡(job)부터 웹 애플리케이션의 백그라운드 워커에 이르기까지 많은 애플리케이션에서 흔하게 큐를 사용
    - Tags: [[green]] 
- 큐는 요청받은 순서대로 요청을 처리하므로 비동기식 요청을 처리하는 완벽한 도구이기도 하다.
- 정해진 순서대로 이벤트가 발생해야 하는 실세계 시나리오를 모델링하는 데 흔하게 쓰인다.
- 재귀는 함수가 자기 자신을 호출할 때를 말하는 공식 명칭
- 모두 노드(node)라는 개념에 기반해 만들어졌다.
- 루프를 사용할 수 있는 경우라면 거의 대부분 재귀도 쓸 수 있다.
- 재귀에 쓰이는 용어로 메서드가 반복되지 않는 이러한 경우를 기저 조건(base case, 중단 조건)이라 부른다.
- 재귀 코드를 읽는 방법
- 기저 조건이 무엇인지 찾는다.
- 기저 조건을 다룬다는 가정하에 함수를 살펴본다.
- 기저 조건 바로 전 조건을 다룬다는 가정하에 함수를 살펴본다.
- 한 번에 한 조건씩 올라가면서 계속 분석한다.
- 기저 조건부터 분석을 시작해서 나아가는 것은 재귀 코드를 추론하는 훌륭한 방법
- 이러한 절차를 따라 재귀를 개념화하는 것은 인간에게만 좋은 방법이 아니다. 컴퓨터도 유사한 접근법을 사용한다.
- 컴퓨터는 factorial(3)을 호출하고 이 메서드가 끝나기 전에 factorial(2)를 호출하고, factorial(2)가 끝나기 전에 factorial(1)을 호출한다. 엄밀히 말해 컴퓨터가 factorial(1)을 실행하는 동안 여전히 factorial(2)를 실행 중이며, 마찬가지로 factorial(3)도 실행하는 중이다.
    - Tags: [[green]] 
- 컴퓨터는 스택을 사용해 어떤 함수를 호출 중인지 기록
- 호출 스택
- 호출 스택에 데이터가 들어 있으므로, 즉 아직 실행 중인 끝내야 할 메서드가 남아 있으므로 컴퓨터는 factorial(1)을 끝냈더라도 해야 할 일이 다 끝나지 않았음을 알고 있다.
- 컴퓨터가 할 다음 작업은 호출 스택 가장 위 원소를 가져오는 것
- 스택은 비어 있으므로 컴퓨터는 메서드를 모두 실행했음을 알게 되고, 재귀는 끝난다.
- 무한 재귀가 있을 때 프로그램은 컴퓨터 메모리에 더 이상 공간이 없을 때까지 계속해서 같은 메서드를 호출 스택에 푸시
- 스택 오버플로
- 재귀는 한 알고리즘 내에서 같은 알고리즘을 반복해야 하는 상황과 자연스럽게 들어맞는다.
- 코드를 훨씬 더 빠르게 실행시킬 수 있는 알고리즘에서도 재귀가 핵심 기술임을 배우겠다.
- 컴퓨터 언어 중 대다수가 내부적으로 채택한 정렬 알고리즘이 바로 퀵 정렬
- 퀵 정렬의 동작 방식을 공부함으로써 재귀를 사용해 어떻게 알고리즘의 속도를 크게 향상시키는지 배울 수 있고, 실제 쓰이고 있는 다른 실용적인 알고리즘에도 똑같이 적용할 수 있기 때문이다.
- 퀵 정렬은 분할이라는 개념에 기반
- 배열로부터 임의의 수를 가져와(이후 이 수를 피벗이라 부름) 피벗보다 작은 모든 수는 피벗의 왼쪽에, 피벗보다 큰 모든 수는 피벗의 오른쪽에 두는 것
- 가장 오른쪽에 있는 값을 항상 피벗으로 고르겠다(물론 기술적으로 다른 값을 고를 수도 있다)
    - Tags: [[green]] 
- “포인터”를 사용해 하나는 배열 가장 왼쪽에 있는 값에, 다른 하나는 피벗을 제외한 배열 가장 오른쪽에 있는 값에 할당
    - Tags: [[green]] 
- partition! 메서드는 왼쪽 포인터와 오른쪽 포인터의 시작점을 매개변수로 받아 왼쪽 포인터가 끝났을 때의 최종 위치를 반환
- 루비로 구현한 SortableArray 클래스로 지금까지 설명한 방법대로 배열을 분할하는 partition! 메서드를 포함
- 피벗의 왼쪽과 오른쪽에 있는 하위 배열을 각각 또 다른 배열로 보고 1단계와 2단계를 재귀적으로 반복
- 하위 배열이 원소를 0개 또는 1개 포함하면 기저 조건이므로 아무것도 하지 않는다.
