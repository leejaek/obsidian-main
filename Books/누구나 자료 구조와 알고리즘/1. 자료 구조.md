---
book: 누구나 자료구조와 알고리즘
tags: 자료구조, 데이터, 배열, 집합
---


title: 소프트웨어 공학자의 목표: 동작 → 품질
경험이 쌓이면서 같은 동작을 하는 두 코드 사이에서 품질 측면에서 미묘한 차이들을 익혀나감

```python
def print_numbers_version_one():
	number = 2

	while number <= 100:
		# number가 짝수면 출력
		if number % 2 == 0:
			print(number)
		number += 1

def print_numbers_version_two():
	number = 2

	while number <= 100:
		print(number)

		# 정의에 따라 다음 짝수로 2씩 증가
		number += 2
```

# 자료 구조
## 데이터
모든 유형의 정보를 망라하는 용어, 가장 기초적인 수, 문자열로 이루어짐
아무리 복잡한 [[데이터]]라도 대부분 '수'와 '문자열' 묶음으로 나뉨

## 자료 구조
데이터를 조직하는 방법
**코드의 실행 속도에 미치는 영향이 매우 큼**

```python
# 1
x = "Hello! "
y = "How are you "
z = "today?"

print(x + y + z)

# 2 
array = ["Hello! ", "How are you ", "today?"]
print(array[0] + array[1] + array[2])
```
---
# 자료 구조 연산

**[[자료 구조]] 성능**을 알려면, **코드 ↔ 자료구조 간 일반적인 상호작용을 분석**

### 연산
#### 읽기: 자료 구조 내 특정 위치의 값을 찾는 것
#### 검색: 자료 구조 내 특정 값의 위치를 찾는 것
#### 삽입: 자료 구조에 새로운 값을 추가하는 것
#### 삭제: 자료 구조에서 값을 제거하는 것

## 연산 속도 측정

**“시간" 관점이 아닌 “단계" 관점**에서 필요성을 논해야 함
- 시간은 하드웨어 성능에 따라 객관적이지 않음

연산 속도 측정 → 연산의 **시간 복잡도** 측정으로 보통 부름
-   속도, 시간 복잡도, 효율성, 성능 네 가지 단어 모두 같은 의미로써 사용
---
# 배열
데이터 원소들의 리스트

```python
array = ["apples", "bananas", "cucumbers", "datas", "elderberries"]
```

크기: 배열에 포함된 데이터 원소 개수
인덱스: 특정 데이터의 배열 상 위치

## 연산 및 속도
### 읽기: O(1)

**과정**
인덱스 `3`에 들어있는 값을 가져옴

```ad-note
title: 컴퓨터 메모리의 특성: 메모리 주소를 활용해 특정 메모리 값에 한번에 접근
컴퓨터 메모리: **특정 주소가 할당된 셀로 구성된 거대 컬렉션**
각 메모리의 주소는 앞 셀의 주소에서 1씩 증가
컴퓨터는 이 **메모리 주소를 활용해서, 검색과정 없이 한 번에 해당 위치로 접근**
```

```ad-note
title: 배열 선언 과정: 메모리의 배열 할당 후, 해당 배열 시작 위치의 메모리 주소를 기록해둠
컴퓨터는 프로그램이 사용할 연속된 빈 셀들의 집합을 할당
해당 **배열이 어떤 메모리 주소에서 시작하는지 기록**해둠
```

![[Screen Shot 2022-02-12 at 12.48.22 PM.png]]
1.  배열의 인덱스는 0부터 시작, 인덱스 0의 메모리 주소는 1010
2.  인덱스 3은 인덱스 0부터 세 슬롯 뒤에 위치
3.  1010 + 3 = 1013 메모리 주소에 접근 ⇒ `"dates"` 값을 찾음

**속도:** $O(1)$    

**배열의 읽기는 가장 빠른 연산 유형 중 하나**


### 검색: O(N)

과정: **[[선형 검색]]**

```ad-note
title: 컴퓨터는 모든 메모리 주소에 한 번에 접근하지만, 각 메모리 주소에 어떤 값이 있는지 알지 못함
```
특정 값 `dates` 가 식료품 목록에 있는지, 어떤 인덱스에 있는지 알아보는 것

1.  인덱스 0의 값을 확인
2.  인덱스 1의 값을 확인
3.  인덱스 2의 값을 확인
4.  인덱스 3의 값을 확인 → “dates” 를 찾음

**속도: $O(N)$**
검색은 읽기보다 비효율적이며, 배열의 크기에 따라 필요한 단계가 커짐

### 삽입: O(N)

**과정**
특정 값(`”figs”`)를 배열의 인덱스 2에 추가
1.  가장 마지막 원소 `"elderberries"` 를 새로 할당한 공간으로 이동
2.  그 이전 원소 `"dates"` 를 하나 뒤의 공간으로 이동
3.  그 이전 원소 `"cucumbers"` 를 하나 뒤의 공간으로 이동
4.  `"figs"` 를 인덱스 2에 삽입

**속도: $O(N)$**

### 삭제: O(N)

**과정**
배열 내의 특정 값(`”cucumbers”`)를 배열에서 제거하는 것
1.  배열에서 인덱스 2의 `"cucumbers"` 를 삭제
2.  `"dates"` 를 왼쪽으로 하나 옮김
3.  `"elderberries"` 를 왼쪽으로 하나 옮김

**속도: $O(N)$**

---
# 집합
중복 값을 허용하지 않는 자료 구조

```ad-note
집합에는 다양한 종류가 있는데, 여기에서는 배열 기반 집합을 다룸
배열과 유일하게 다른 점은 중복 값 삽입을 허용하지 않는 점
```
## 연산 및 속도
읽기, 검색, 삭제의 경우 앞서 살펴 본 배열의 연산 과정과 동일

### 삽입: O(N)
[[집합]]에서의 삽입은 중복된 데이터가 있는지 확인을 위해 검색($O(N)$)이 선행됨
최악의 경우 2N + 1 단계가 소요
배열보다 비효율적

# 정리
[[집합]]과 [[배열]]의 규칙 차이는 한 가지: 중복 허용 여부
- 이 규칙으로 인해 자료 구조의 연산 과정 (삽입 과정)에 차이가 발생

애플리케이션(프로그램)에 필요한 [[자료 구조]]를 선택할 것
- ex. 중복 필터링이 꼭 필요한가?

[[자료 구조]] 성능 측정: **연산에 필요한 단계 수를 구하는 것이 핵심**
