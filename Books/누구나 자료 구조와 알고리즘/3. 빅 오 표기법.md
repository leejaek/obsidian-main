---
book: 누구나 자료구조와 알고리즘
tags: 빅오표기법, 알고리즘
---

# 빅 오
알고리즘의 효율성을 쉽게 분류하고 이해하기 위한 방법
**"데이터 원소가 N개일 때, 알고리즘에 몇 단계가 필요한가"**

데이터가 늘어날 때, [[알고리즘]]의 성능이 어떻게 바뀌는지를 측정

최악의 시나리오를 가정함
- 최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 알면, 최악을 대비함과 동시에 알고리즘 선택에 중요한 인사이트를 줌


## O(N) vs O(1)
![[Screen Shot 2022-03-01 at 4.23.33 PM.png]]
- [[배열]]의 [[읽기]] N과 상관없이 1 단계가 필요: $O(1)$ - 상수 시간을 갖는 알고리즘
- [[배열]]의 [[검색]] : $O(N)$
	- [[for 루프]] 등이 $O(N)$ 알고리즘에 속함

만약 $O(100000)$ 과 $O(N)$ 인 알고리즘이 있다면, 
데이터가 증가하면서 $O(N)$ 이 $O(100000)$ 보다 비효율적인 시점이 오고 이후로 무한대로 갈 때까지 계속 비효율적인 상태가 유지됨

## O(logN)
[[이진 검색]]의 경우 $O(logN)$ 와 같이 로그 시간의 시간복잡도를 가짐

데이터가 두 배 증가할 때마다 한 단게씩 늘어나는 알고리즘
- 결과값이 1이 될 때까지 데이터 원소를 계속 2로 나누는 만큼의 단계 수
![[Screen Shot 2022-03-01 at 4.29.49 PM.png]]
```ad-info
title: 로가리즘

[[로가리즘]](logarithm)의 줄임말이 로그
[[지수]](exponenet) 와 [[역]](inverse)의 관계
```

# 결론
빅 오 표기법을 통해 알고리즘 간 비교를 할 수 있게 됨