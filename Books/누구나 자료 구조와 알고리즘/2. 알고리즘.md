---
book: 누구나 자료구조와 알고리즘
tags: 알고리즘, 이진검색, 선형검색
---
# 알고리즘
어떤 과제를 완수하는 명령어 집합
- 어떤 코드를 작성하든 컴퓨터가 따르고 실행한 알고리즘을 만드는 것

[[자료 구조]] 뿐만 아니라 [[알고리즘]] 또한 코드 효율성에 영향을 미치는 중요한 요인

동일한 Task 를 둘 이상의 알고리즘을 통해 완성할 수 있음

# 정렬된 배열
원소가 항상 순서대로 정렬된 배열
## 연산 및 속도
### 삽입 (O(N))
**과정**
`[3, 17, 80, 202]` 배열에 `75` 를 추가하고자 함
1. 인덱스 0의 값(`3`)을 확인, 75가 왼쪽 - 오른쪽으로 들어갈지 정함
2. 다음 셀의 값(`17`)을 확인
3. 다음 셀의 값(`80`)을 확인
	- `75` 보다 큰 값이므로, 더 이상 다음 값을 확인하지 않음
4. 마지막 셀의 값(`202`)을 오른쪽으로 이동
5. 마지막 앞 셀의 값 (`80`)을 오른쪽으로 이동
6. `75`를 삽입

삽입에 필요한 단계 수는 새 값이 정렬된 배열 어디에 놓이든 비슷
- 배열 앞 부분: 비교 ↓ // 이동 ↑
- 배열 뒷 부분: 비교 ↑ // 이동 ↓

속도: $O(N)$
- 정확히 $N + 2$ 단계가 소요되며, 일반 배열보다 삽입 과정에서 비효율적

### 검색

#### 선형 검색 (linear search) (O(N))
기존 [[배열]]의 검색 방식: [[선형 검색]]

```ruby
def linear_search(array, search_value)
	# 배열의 모든 원소 순회
	array.each_with_index do |element, index|

		# 원하는 값을 찾으면 그 인덱스 반환
		if element == search_value
			return index
		# 찾고 있던 값보다 큰 원소에 도달하면 루프를 일찍 종료
		elsif element > search_value
			break
		end
	end
	# 배열에서 값을 찾지 못하면 nil 을 반환
	return nil
end
```

기존 배열의 [[선형 검색]]과 비교해, 찾고자 하는 숫자보다 큰 수가 등장하면 바로 종료할 수 있으므로, 비교적 빠름
찾으려는 값이 배열의 마지막 값 or 마지막 값보다 큰 값이면 모든 셀을 검색해야 종료

#### 이진 검색 (binary search) (O(logN))
정렬된 배열에서만 사용할 수 있는 검색 방법: [[이진 검색]]

방법
정렬된 배열에서 값 `7`을 찾고자 함
1. 가운데 셀부터 검색을 시작
	- 배열의 길이를 2로 나누어 셀의 값을 확인(`9`)
2. `9` 보다 왼쪽에 있는 셀들 중 가운데 값을 확인 (`4`)
3. `4` 와 `9` 사이에 있는 셀 중 임의의 셀을 확인 (`6`)
4. `6` 과 `9` 사이에 있는 셀을 확인 (`7`)

```js
function binary_search(array, value) {
	// 찾으려는 값의 상한선, 하한선을 정함
	// 최초의 상한선: 배열의 첫 번째 값, 하한선: 마지막 값
	let first = 0
	let last = array.length - 1

	while (first <= last) {
		let middle = Math.round((last + first) / 2);
		let middle_value = array[middle];

		if (middle_value === value) {
			return middle;
		} else if (middle_value > value) {
			last = middle;
		} else if (middle_value < value) {
			first = middle;
		}
	}
	return null;
}
```

속도: $N(logN)$
- 크기가 작은 배열이라면 선형 검색과 큰 차이가 없지만, 배열이 커질수록 효율성이 매우 높아짐

# 결론

[[검색]]을 위한 두 가지 [[알고리즘]]
[[선형 검색]] 
- 원소 수와 비례하여 필요한 단계가 증가
[[이진 검색]]
- 원소 수가 두 배 늘어날 때, 필요한 단계가 1 증가
- [[정렬된 배열]]에서만 사용 가능함

![[Screen Shot 2022-03-01 at 4.13.12 PM.png]]

[[정렬된 배열]]은 [[삽입]] 에서 [[배열]] 보다 느리지만, [[검색]] 에서 배열보다 크게 빠름
- [[삽입]] 과정을 위한 [[검색]] 에서도 [[이진 검색]] 을 적용한다면 개선 가능함

> 애플리케이션에 삽입이 자주 일어나는가? 검색 기능 성능이 중요한가?

[[알고리즘]] 간 성능 분석 방법: 각각에 필요한 단계 수를 세는 것
- [[자료 구조]] 와 동일!