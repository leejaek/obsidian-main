# Docker
- 도커는 **[[컨테이너]] 기술**: ==컨테이너를 만들고 관리하기 위한 기술 스택==이다.

# 컨테이너
- ==**표준화된 소프트웨어 유닛**==
- 코드, 코드를 실행하기 위한 dependencies 를 모두 포함
	- 예) NodeJS 코드로 작성한 서버 컨테이너는 NodeJS 런타임, 각종 패키지를 포함하고 있음
- 동일한 컨테이너를 사용할 경우, 어디에서나 ==**동일한 동작, 결과를 제공하는 이점**==이 있음
- 최근 운영체제는 대부분 컨테이너 기술을 지원하며, 도커를 설치해서 작업할 수 있음
- 컨테이너를 사용하지 않아도 된다. 하지만, 작업을 간단하게 표준화하는 측면에서 매우 큰 이점이 있다.

## 표준화된 소프트웨어 유닛(컨테이너)이 필요한 이유
1. ==개발 환경과 프로덕션 환경이 다를 수 있음 (local, dev, production) **[환경 간 충돌]**==
	- '환경': 런타임, 언어, 프레임워크와 같이 개발에 필요한 모든 것
	- 예) NodeJS 14.3 버전에서 잘 실행되는 코드를 작성
	  → 이것이 다른 서버 환경에서도 잘 돌아갈까? 만약 서버에 NodeJS 12 버전이 있다면?
	- **동일한 개발환경 구축: 문제 발생 확률을 줄이고, 다른 환경에서도 디버깅, 테스트를 쉽게 함**
2. ==팀 내부, 회사 내부의 컴퓨터 간 다른 개발 환경 **[팀원 간 환경 충돌]**==
	- ==소프트웨어 개발에서 '재현성'이 중요==하며, 프로젝트 팀원들은 손쉽게 동일한 개발 환경 구축이 가능해야 함
3. ==여러 프로젝트 간 다른 환경이 필요할 수 있음 **[프로젝트 간 환경 충돌]**==
	- 특정 프로젝트에 파이썬2를 사용하고 다른 프로젝트에 파이썬3를 사용할 수 있음
	- 프로젝트마다 다른 환경을 매번 구축하는 것은 어려움
	- 컨테이너를 구축해두면, 컨테이너 시작을 통해 프로젝트 전환이 쉽게 가능함

# 가상 머신
호스트 OS에 버츄얼 머신을 설치하는 방식으로 독립적인 운영 체제를 구축할 수 있음
- 해당 운영체제 위에 다시 필요한 환경을 구축할 수 있음

버츄얼 머신을 활용하면 도커-컨테이너를 활용한 것과 동일하게 캡슐화된 환경 구축이 가능함

## 가상 머신 대신 컨테이너를 활용하는 이유
가상 머신은 ==각자 '가상 운영체제'를 가지고 있다는 점이 문제 → [[오버헤드]]가 발생==
- 각종 리소스 (메모리, CPU, 하드 드라이브)를 가상 운영체제에 재분배하면서 리소스 낭비가 발생
- 만약 동일하게 '리눅스'를 사용하는 환경을 구축해도, 모든 버츄얼 머신이 동일한 '리눅스' 운영체제를 모두 가짐
Hard to reproduct on another computer (==도커처럼 단일 구성파일로 설정을 만들어서 손쉽게 공유할 수 없음==)

![[Screen Shot 2022-04-02 at 12.16.16 AM.png]]

# 도커와 컨테이너의 동작

> **컨테이너가 핵심 기술!**
> 도커는 컨테이너를 관리하기 위한 (사실상의) 표준 도구일 뿐

- 기본적으로 호스트 운영체제가 존재 (macOS, Windows, Linux 등)
- 그 위에 OS에 내장된 혹은 에뮬레이터를 통해 컨테이너 기술을 활용
- 그 위에 Docker Engine 을 설치
- 그 위에 별개의 컨테이너로 구분
	- 컨테이너에는 코드와 코드 실행을 위한 의존성들로 구성
	- 운영체제, 추가적인 도구 등은 포함하지 않음
	- 컨테이너 내부에 ==*작은 운영체제 레이어가 있지만 버추얼 머신에 비하면 매우 가벼움*==

![[Screen Shot 2022-04-02 at 12.11.52 AM.png]]

컨테이너의 좋은 점 중 하나는 ==구성 파일을 통해 컨테이너를 구성하고 정의==할 수 있음
- 파일을 손쉽게 공유하여 다른 사람이 동일한 컨테이너를 만들도록 하거나, 이미지를 빌드할 수 있음
- 이미지를 공유함으로써도 동일한 컨테이너를 다른 환경에서 시작할 수 있음

# Docker 설치
https://www.docker.com/

- Linux 는 기본적으로 Native 하게 컨테이너 기술을 지원하기 때문에 별도의 요구사양이 없음
- macOS, Windows 의 경우 요구사양이 있으며, 해당 요구사양을 만족하지 못한 경우 Docker Toolbox 를 사용

# Docker 관련 도구들

![[Screen Shot 2022-04-02 at 11.49.04 AM.png]]

## Docker Engine
- Docker Engine은 Docker 를 실행하는데 필요한 Linux 를 호스팅하는 가상머신에 설정
- [[운영체제]]가 기본적으로 도커를 지원하지는 않기 때문에 가상머신을 사용
- 해당 가상 머신에서 컨테이너가 실행됨

## Docker Desktop
- Docker Desktop은 Docker Engine이 설치되고 작동하는지 확인하는 도구
- [[데몬]]과 [[CLI]] 를 포함함
- [[데몬]]: 데몬 프로세스는 지속적으로 실행되며, Docker가 작동하는지 확인함
- [[CLI]]: 전체 과정에서 Docker가 명령을 실행하도록 하기 위해 사용할 도구

## Docker Hub
- 클라우드, 웹에 이미지를 호스팅하여 다른 사람들과 쉽게 공유할 수 있게 해줌

## Docker Compose
- Docker 를 기반으로 해서 더 복잡한 컨테이너 또는 다중 컨테이너를 쉽게 관리할 수 있게 해줌

## Kubernetes
- 복잡하게 컨테이너화된 애플리케이션 배포 및 관리에 도움을 줌


# 연습

! NodeJS 예제 파일이 주어지는데, NodeJS 를 알지 못하더라도 실습에는 전혀 문제가 없음

NodeJS 예제 코드를 **'로컬'에서 실행**하려면, 
1. https://nodejs.org 홈페이지에서 다운로드
2. 코드의 `package.json` 에 포함된 dependencies 를 다운로드
3. `node app.mjs`로 코드를 실행

NodeJS 예제 코드를 **'도커'에서 실행**하려면,
1. Dockerfile을 생성
	- 컨테이너 설정을 작성함
	- 모든 컨테이너에는 자체 파일 시스템이 존재하며, WORKDIR 지정이 필요함
	- 외부와의 연결을 위해서 EXPOSE 를 통해 포트 번호를 설정
2. 이미지를 생성 : `docker build .
3. 컨테이너를 생성하여 실행 : `docker run -p 3000:3000 080858f`
	- 컨테이너와 호스트 운영체제 사이에 디폴트 연결이 없기 때문에, 실행중인 컨테이너 내부의 애플리케이션에 네트워크 연결을 보내기 위해서는 위와 같이 `-p` 키워드로 포트 연결을 해야 함
4. `docker ps` 로 실행 중인 컨테이너 확인 후, `docker stop [컨테이너명]` 을 입력

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 3000

CMD [ "node", "app.mjs" ]
```


# Course Outline




