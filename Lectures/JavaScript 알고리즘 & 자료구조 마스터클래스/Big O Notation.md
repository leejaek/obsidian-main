---
type: lecture
book: JavaScript 알고리즘 & 자료구조 마스터클래스
chapter: 2
date: 2022-05-02
tags: Big-O, 빅오
---
- 빅오 표기법에는 ‘수학적’ 지식을 포함함

## Big O Notaion 의 필요성
- 이 코스에 나오는 각 주제마다 수많은 해결법이 존재
- 만약 하나는 Loop를 이용, 다른 하나는 List나 String을 활용
- 어떤 것이 더 나은 방법인가?
- Big O 는 코드를 비교하고 성능을 평가하는 방법

> Write a function that accepts a string input and retuns a reversed copy
	- 10가지 이상의 완전히 다른 방법들이 존재함

- 코드를 분류해서 성능이 좋고 나쁨을 표현할 수 있어야 함
	→ 이를 위해 Big O Notation을 사용할 수 있음

- Who Cares?
	- 성능이 그렇게 중요한가? 일단 잘 작동하면 되는 것 아닌가?
		- 프로젝트에 따라서 그럴 수도 있지만, Interview, Code Challenge 혹은 매우 거대한 규모의 서비스를 하는 회사에서는 알고리즘 실행 시간, 즉 성능이 중요함
	- 코드의 성능을 객관적으로 표현할 수 있는 방법이 필요함
	- 여러 접근법의 장단점을 비교해서 최선의 해결책을 찾는데 유용
		- 단순히 한 접근법이 무조건 좋고 나쁘고는 없음, 어떤 것은 메모리를 많이 활용하고 어떤 것은 시간을 많이 활용하기도
	- 디버그를 할 때 도움이 됨 → 어떤 연산 부분에서 시간을 많이 잡아먹는가?
	- 인터뷰에서 특정 알고리즘의 빅오를 자주 물어봄

## 코드 시간 재기
> Write a function that calculates the sum of all numbers from 1 up to (and including) some number $n$.

```js
function addUpTo(n) {
	let total = 0;
	for (let i = 1; i <= n; i++) {
		total += i;
	}
	return total;
}
```

좀 더 수학 공식에 가깝게 아래와 같이 알고리즘을 새울 수 있음
```js
function addUpTo(n) {
	return n * (n + 1) / 2;
}
```

### 이 두 코드 중 무엇이 더 나은가?
- ‘더 낫다’ 라는 의미는 ?
	- 빠른 속도로 처리하는 것?
	- 메모리를 적게 사용하는 것?
	- 코드의 가독성이 좋은 것? / 코드를 적게 쓰는 것?
- 여기에서는 **속도**를 우선적으로 살펴봄

### 코드 실행 시간 측정
```js
let t1 = performance.now();
addUpTo(100000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds`)
```

이 방법으로 코드 위의 두 가지 코드의 실행시간을 각각 실행한 결과,
- 1번째 방식은 0.1137초, 2번째 방식은 0초가 소요됨
- 주어진 숫자가 커질수록 이 차이는 기하급수적으로 커짐

### The Problem with Time
- 같은 문제를 해결하더라도 문제를 해결하는 더 좋은 효율적인 방법이 있다.
- 하지만 수기로 직접 코드의 실행 시간을 측정해서 코드 효율성을 비교하는 것은 비효율적
	- 코드를 실행하는 기기에 따라 실행 속도는 차이가 있을 수 있음
	- 같은 기계더라도, 코드 실행시간을 경우에 따라 차이가 남
	- 매우 빠른 속도로 실행이 되는 알고리즘의 경우는, 미세한 시간 차이를 측정하기 어려움
- 코드 실행 속도를 측정하는 방법 자체를 부정하는 것은 아님
- 다만, 이보다 더 객관적인 측정 지표가 필요함

### If not time, then what? Counting Operations
- 시간(초)를 세는 대신에,
- **컴퓨터가 수행해야하는 연산의 갯수**를 계산
	- 2번째 알고리즘의 경우, 3개의 연산으로 연산 과정이 끝남 ($n$의 크기와 독립적)
	- 1번째 알고리즘의 경우, $n$의 갯수가 커짐에 따라 비례해서 연산 횟수가 증가함
	![[Screen Shot 2022-05-02 at 11.38.59 PM.png]]
### Counting is hard!
- 하지만, 연산을 직접 하나씩 모두 세는 것은 어려움
- $5n + 2$, $2n$ 등 구체적인 숫자보다, 전체적인 ‘추세'를 보는 것이 더욱 중요함

